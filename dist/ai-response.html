<!DOCTYPE html>
<html>
<head>
    <title>MockMate AI: Response Window</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #000000;
            --secondary-bg: rgba(0, 0, 0, 0.7);
            --panel-bg: rgba(0, 0, 0, 0.7);
            --accent: #00d4ff;
            --accent-secondary: #ff6b35;
            --success: #00c896;
            --danger: #ff4757;
            --warning: #ffa502;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.7);
            --border: rgba(255, 255, 255, 0.15);
            --border-active: rgba(0, 212, 255, 0.4);
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.4);
            --gradient-primary: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 107, 53, 0.05));
            --gradient-panel: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
        }
        
        * { box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'SF Pro Display', system-ui, sans-serif;
            background: transparent;
            margin: 0;
            padding: 0;
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: stretch;
            width: 800px;
            height: auto;
            min-height: 80px;
            line-height: 1.6;
            font-size: 10.74px;
            overflow: visible;
            /* Remove any max-height constraints */
            max-height: none;
        }
        
        .app-container {
            width: 100%;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            position: relative;
            /* Remove any height constraints */
            max-height: none;
        }
        
        .response-window {
            width: 100%;
            min-height: 80px;
            background: rgba(0, 0, 0, 0.80);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            overflow: visible;
            position: relative;
            /* Remove any height constraints */
            max-height: none;
        }
        
        .response-window::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--gradient-primary);
            opacity: 0.3;
            pointer-events: none;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--gradient-panel);
            position: relative;
            z-index: 2;
            gap: 12px;
            flex-shrink: 0;
        }
        
        .brand { display: flex; align-items: center; gap: 12px; }
        
        .logo {
            width: 32px; height: 32px;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; color: white;
            box-shadow: var(--shadow-sm);
        }
        
        .brand h2 {
            font-size: 13.81px; margin: 0; font-weight: 600; letter-spacing: -0.2px;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .status-pill {
            background: rgba(0, 200, 150, 0.15); color: var(--success);
            padding: 6px 12px; border-radius: 20px; font-size: 9.2px;
            font-weight: 500; border: 1px solid rgba(0, 200, 150, 0.2);
            margin-left: 16px; animation: pulse 2s infinite;
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        .utility-btn {
            width: 28px; height: 28px; background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--border); border-radius: 6px; color: var(--text-secondary);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; font-size: 10.74px;
        }
        
        .utility-btn:hover { background: rgba(0, 0, 0, 0.9); color: var(--text-primary); transform: translateY(-1px); }
        .utility-btn.danger:hover { background: rgba(255, 71, 87, 0.2); color: var(--danger); border-color: var(--danger); }
        
        .content-area {
            padding: 16px; 
            margin: 0;
            background: transparent; 
            font-size: 16.11px;
            font-weight: bold;
            line-height: 1.3; 
            height: auto;
            overflow: visible;
            word-wrap: break-word;
            white-space: pre-wrap;
            z-index: 2;
            min-height: 40px;
            /* Allow natural expansion without scrolling */
        }
        
        .streaming-indicator {
            width: 8px; height: 8px; background: var(--accent);
            border-radius: 50%; animation: blink 1.5s infinite;
            box-shadow: 0 0 8px var(--accent);
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0.3; } }
        
        .material-icons {
            font-family: 'Material Icons'; font-weight: normal; font-style: normal;
            font-size: 15.34px; display: inline-block; line-height: 1; text-transform: none;
            letter-spacing: normal; word-wrap: normal; white-space: nowrap; direction: ltr;
            -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
            -moz-osx-font-smoothing: grayscale; font-feature-settings: 'liga';
        }
        
        /* Hide Scrollbars */
        ::-webkit-scrollbar {
            width: 0px;
            height: 0px;
            background: transparent;
        }
        
        /* For Firefox */
        * {
            scrollbar-width: none;
        }
        
        /* For IE and Edge */
        body {
            -ms-overflow-style: none;
        }
        
        /* Animation for cursor in typing effect */
        .cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background-color: var(--accent);
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: middle;
        }
        
        @keyframes slideInFromBottom {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideOutToBottom {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(20px); opacity: 0; }
        }
        
        /* Markdown Formatting CSS */
        .markdown-content {
            /* Base markdown styling */
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        /* Bold text: **text** */
        .markdown-content {
            /* Use CSS to style markdown patterns */
            position: relative;
        }
        
        /* JavaScript will add these classes for markdown patterns */
        .md-bold {
            font-weight: bold;
            color: var(--text-primary);
        }
        
        .md-italic {
            font-style: italic;
            color: var(--text-secondary);
        }
        
        .md-bold-italic {
            font-weight: bold;
            font-style: italic;
            color: var(--text-primary);
        }
        
        /* Header styles for markdown */
        .md-header-1 {
            font-size: 1.6em;
            font-weight: bold;
            color: var(--accent);
            margin: 16px 0 8px 0;
            display: block;
        }
        
        .md-header-2 {
            font-size: 1.4em;
            font-weight: bold;
            color: var(--accent);
            margin: 14px 0 7px 0;
            display: block;
        }
        
        .md-header-3 {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--accent);
            margin: 12px 0 6px 0;
            display: block;
        }
        
        /* Code blocks and inline code */
        .md-code-inline {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--accent);
        }
        
        .md-code-block {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
            color: var(--text-primary);
            overflow-x: auto;
            display: block;
        }
        
        /* Remove problematic list item styles that were causing dash issues */
        
        /* Link styling */
        .md-link {
            color: var(--accent);
            text-decoration: underline;
            cursor: pointer;
        }
        
        .md-link:hover {
            color: var(--accent-secondary);
        }
        
        /* Blockquote styling */
        .md-blockquote {
            border-left: 4px solid var(--accent);
            padding-left: 16px;
            margin: 8px 0;
            color: var(--text-muted);
            font-style: italic;
            display: block;
        }
        
        /* Horizontal rule */
        .md-hr {
            border: none;
            border-top: 2px solid var(--border);
            margin: 16px 0;
            display: block;
        }
    </style>
    <!-- Tauri API Script -->
    <script>
        // Ensure Tauri API is available in child windows
        if (!window.__TAURI__) {
            console.log('🔧 Tauri API not found, attempting to load...');
            // Try to get it from parent or main context
            try {
                if (window.parent && window.parent.__TAURI__) {
                    window.__TAURI__ = window.parent.__TAURI__;
                    console.log('✅ Tauri API loaded from parent window');
                } else if (window.opener && window.opener.__TAURI__) {
                    window.__TAURI__ = window.opener.__TAURI__;
                    console.log('✅ Tauri API loaded from opener window');
                }
            } catch (e) {
                console.warn('❌ Could not access parent/opener Tauri API:', e);
            }
        } else {
            console.log('✅ Tauri API already available');
        }
    </script>
</head>
<body>
    <div class="app-container">
        <div class="response-window">
            <div id="contentArea" class="content-area">Waiting for AI response...</div>
        </div>
    </div>
    <script>
        let currentText = '';
        let typewriterTimeout = null;
        let streamingActive = false;
        
        // Wait for Tauri API to be available
        function waitForTauri(callback, maxAttempts = 50) {
            let attempts = 0;
            const checkTauri = () => {
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    console.log('✅ Tauri API is now available');
                    callback();
                } else if (attempts < maxAttempts) {
                    attempts++;
                    console.log(`⏳ Waiting for Tauri API... (${attempts}/${maxAttempts})`);
                    setTimeout(checkTauri, 100);
                } else {
                    console.warn('❌ Tauri API not available after max attempts');
                    callback(); // Continue without Tauri
                }
            };
            checkTauri();
        }
        
        // Initialize when the window is loaded
        window.addEventListener('DOMContentLoaded', () => {
            // Get references to elements
            const closeBtn = document.getElementById('closeBtn');
            const testResizeBtn = document.getElementById('testResizeBtn');
            const contentArea = document.getElementById('contentArea');
            
            
            
            // Wait for Tauri API and then set up observers
            waitForTauri(() => {
                setupAutoHeightObservers(contentArea);
                console.log('AI Response window loaded and ready with auto-height observers');
            });
        });
        
        // Function to reset window to initial state
        function resetToInitialState() {
            console.log('🔄 Resetting window to initial state');
            const contentArea = document.getElementById('contentArea');
            
            // Reset content
            contentArea.innerHTML = 'Waiting for AI response...';
            
            // Reset variables
            currentText = '';
            streamingActive = false;
            
            // Clear any pending timeouts
            if (typewriterTimeout) {
                clearTimeout(typewriterTimeout);
                typewriterTimeout = null;
            }
            
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
                resizeTimeout = null;
            }
            
            // Reset window size to initial state
            setTimeout(() => adjustWindowHeight(), 100);
        }
        
        // Global function to update content (called from Tauri)
        window.updateContent = function(type, data) {
            console.log('🎯 AI RESPONSE WINDOW: updateContent called with type:', type);
            console.log('🎯 AI RESPONSE WINDOW: Raw data received:', JSON.stringify(data).substring(0, 200));
            const contentArea = document.getElementById('contentArea');
            
            // Check if data is actually JSON string instead of parsed object
            if (typeof data === 'string' && (data.startsWith('{') || data.startsWith('"{'))) {
                console.warn('⚠️ Data appears to be a JSON string, attempting to parse');
                try {
                    if (data.startsWith('"')) {
                        data = JSON.parse(data);
                        if (typeof data === 'string') {
                            data = JSON.parse(data);
                        }
                    } else {
                        data = JSON.parse(data);
                    }
                    console.log('✅ Successfully parsed JSON data');
                } catch (e) {
                    console.error('❌ Error parsing JSON data:', e);
                    return; // Exit if data is corrupted
                }
            }
            
            // Extract the actual text/token content
            let incomingText = '';
            if (data && typeof data === 'object') {
                if (type === 'stream') {
                    incomingText = data.text || '';
                } else if (type === 'stream-token') {
                    incomingText = data.token || '';
                } else if (type === 'complete') {
                    incomingText = data.text || '';
                }
                
                // Clean up execution context JSON if it accidentally got included
                if (incomingText && incomingText.includes('{"execution_context"')) {
                    const cleanedText = incomingText.split('{"execution_context"')[0];
                    console.warn('⚠️ Removed execution context from text:', {
                        original: incomingText.substring(0, 100),
                        cleaned: cleanedText.substring(0, 100)
                    });
                    incomingText = cleanedText;
                }
            }
            
            switch (type) {
                case 'stream':
                    // Full text replacement - this should be the complete accumulated text
                    if (!streamingActive) {
                        console.log('🚀 New streaming session started');
                        resetToInitialState();
                        streamingActive = true;
                    }
                    
                    // For 'stream' type, we expect the full accumulated text
                    currentText = incomingText;
                    
                    console.log('🔄 Stream update (full replacement):', {
                        type: 'stream',
                        newLength: currentText.length,
                        preview: currentText.substring(0, 150),
                        lastChars: currentText.substring(Math.max(0, currentText.length - 50))
                    });
                    break;
                    
                case 'stream-token':
                    // Incremental token addition
                    if (!streamingActive) {
                        console.log('🚀 New token streaming session started');
                        resetToInitialState();
                        streamingActive = true;
                        currentText = '';
                    }
                    
                    // For 'stream-token', we append the new token
                    const previousLength = currentText.length;
                    currentText += incomingText;
                    
                    console.log('🔄 Token stream update (incremental):', {
                        type: 'stream-token',
                        tokenReceived: JSON.stringify(incomingText),
                        tokenLength: incomingText.length,
                        previousLength: previousLength,
                        newTotalLength: currentText.length,
                        lastChars: currentText.substring(Math.max(0, currentText.length - 100))
                    });
                    break;
                    
                case 'complete':
                    // Final text - use provided text or keep accumulated
                    if (incomingText && incomingText.trim()) {
                        currentText = incomingText;
                    }
                    streamingActive = false;
                    
                    console.log('✅ Stream completed:', {
                        finalLength: currentText.length,
                        preview: currentText.substring(0, 100)
                    });
                    break;
                    
                default:
                    console.warn('⚠️ Unknown update type:', type);
                    return;
            }
            
            // Check for duplication patterns in the current text
            const hasDuplication = currentText.includes('**Scripted Jenkins Pipeline Example** ExampleScripted') ||
                                 currentText.includes('ToTo create create') ||
                                 currentText.includes('DDockerockerfilefile');
            
            if (hasDuplication) {
                console.error('❌ DUPLICATION DETECTED in currentText!');
                console.log('🔍 Full current text:', JSON.stringify(currentText));
                console.log('🔍 Text preview:', currentText.substring(0, 200));
            }
            
            // Update the display
            updateContentWithMarkdown(contentArea, currentText, streamingActive);
            
            // Handle other cases
            if (type === 'error') {
                contentArea.innerHTML = `<span style="color: var(--danger);">Error: ${data.error}</span>`;
            } else if (type === 'debug-raw') {
                contentArea.textContent = incomingText || 'No text provided';
            }
            
            // Adjust height after content update - be more aggressive during streaming
            if (streamingActive) {
                // During streaming, force multiple height checks to ensure accuracy
                setTimeout(() => adjustWindowHeight(), 10);
                setTimeout(() => adjustWindowHeight(), 50);
                setTimeout(() => adjustWindowHeight(), 100);
            } else {
                // When complete, just one check is sufficient
                setTimeout(() => adjustWindowHeight(), 50);
            }
        };
        
        // Function to parse markdown and apply styling
        function parseMarkdownToHTML(text) {
            if (!text) return text;
            
            let html = text;
            
            // Parse code blocks first to protect their content (```code```)
            html = html.replace(/```([\s\S]*?)```/g, '<span class="md-code-block">$1</span>');
            
            // Parse inline code (`code`) - protect from other parsing
            html = html.replace(/`([^`]+)`/g, '<span class="md-code-inline">$1</span>');
            
            // Parse headers (must be at start of line)
            html = html
                .replace(/^### (.*$)/gim, '<div class="md-header-3">$1</div>')
                .replace(/^## (.*$)/gim, '<div class="md-header-2">$1</div>')
                .replace(/^# (.*$)/gim, '<div class="md-header-1">$1</div>');
            
            // Parse bold and italic (***text*** for bold+italic)
            html = html.replace(/\*\*\*([^*]+?)\*\*\*/g, '<strong><em>$1</em></strong>');
            
            // Parse bold (**text**)
            html = html.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
            
            // Parse italic (*text*) - be more careful with boundaries
            html = html.replace(/\*([^*\n]+?)\*/g, '<em>$1</em>');
            
            // Parse links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" style="color: var(--accent); text-decoration: underline;">$1</a>');
            
            // Parse blockquotes (> text)
            html = html.replace(/^> (.+)$/gim, '<div class="md-blockquote">$1</div>');
            
            // Parse horizontal rules (--- or ***) - but NOT single dashes
            html = html.replace(/^[\s]*(-{3,}|\*{3,})$/gim, '<hr style="border: none; border-top: 2px solid var(--border); margin: 16px 0;">');
            
            // Handle line breaks properly
            html = html.replace(/\n\n/g, '<br><br>').replace(/\n/g, '<br>');
            
            return html;
        }
        
        // Enhanced function to update content with markdown parsing
        function updateContentWithMarkdown(element, text, addCursor = false) {
            if (!element) {
                console.warn('❌ No element provided to updateContentWithMarkdown');
                return;
            }
            
            if (!text || text.trim() === '') {
                element.innerHTML = addCursor ? '<span class="cursor">|</span>' : 'Waiting for AI response...';
                return;
            }
            
            // Clean the text first - remove any weird encoding and normalize whitespace
            let cleanText = text
                .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '')
                .replace(/\r\n/g, '\n')
                .replace(/\r/g, '\n');
            
            console.log('📝 Processing text for markdown:', {
                originalLength: text.length,
                cleanedLength: cleanText.length,
                isStreaming: addCursor,
                firstChars: cleanText.substring(0, 100)
            });
            
            // Always parse markdown, even during streaming for real-time formatting
            const parsedHTML = parseMarkdownToHTML(cleanText);
            
            // Add cursor if streaming
            const finalHTML = addCursor ? parsedHTML + '<span class="cursor">|</span>' : parsedHTML;
            
            // Set the content with parsed HTML
            element.innerHTML = finalHTML;
            
            console.log('✅ Markdown parsed and applied:', {
                originalLength: cleanText.length,
                parsedLength: parsedHTML.length,
                hasMarkdown: parsedHTML !== cleanText,
                isStreaming: addCursor
            });
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Typewriter effect function
        function startTypewriter(element) {
            let index = 0;
            element.innerHTML = '';
            
            function typeNext() {
                if (index < currentText.length) {
                    element.innerHTML = currentText.substring(0, index + 1) + '<span class="cursor">|</span>';
                    index++;
                    adjustWindowHeight();
                    typewriterTimeout = setTimeout(typeNext, 30); // 30ms per character
                } else {
                    // Remove cursor when done
                    element.innerHTML = currentText;
                    adjustWindowHeight();
                }
            }
            
            typeNext();
        }
        
        // Optimized window height adjustment for smooth real-time streaming
        let resizeTimeout = null;
        let lastResizeHeight = 0;
        let isResizing = false;
        
        function adjustWindowHeight() {
            // Clear any pending resize timeout
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            // Use requestAnimationFrame for smooth 60fps updates
            resizeTimeout = requestAnimationFrame(() => {
                if (isResizing) return; // Prevent overlapping resize calls
                
                const contentArea = document.getElementById('contentArea');
                if (!contentArea || !window.__TAURI__) return;
                
                // Force layout recalculation to get accurate height during streaming
                contentArea.offsetHeight; // Trigger reflow
                
                // Fast height calculation - use both scrollHeight and offsetHeight for accuracy
                const contentHeight = Math.max(contentArea.scrollHeight, contentArea.offsetHeight);
                const headerHeight = 50;
                const contentPadding = 32;
                const windowPadding = 20;
                
                // Calculate new height
                const screenHeight = window.screen.availHeight || 1080;
                const maxHeight = Math.floor(screenHeight * 0.85);
                const minHeight = 100;
                
                const newHeight = Math.min(Math.max(
                    contentHeight + headerHeight + contentPadding + windowPadding, 
                    minHeight
                ), maxHeight);
                
                // Use smaller threshold during streaming for more responsive updates
                const threshold = streamingActive ? 2 : 5;
                if (Math.abs(newHeight - lastResizeHeight) > threshold) {
                    isResizing = true;
                    lastResizeHeight = newHeight;
                    
                    // Async resize to avoid blocking UI
                    window.__TAURI__.invoke('resize_ai_response_window', { height: newHeight })
                        .then(() => {
                            console.log(`📏 Smooth resize to ${newHeight}px`);
                            isResizing = false;
                        })
                        .catch(err => {
                            console.warn('❌ Resize failed:', err);
                            isResizing = false;
                        });
                } else {
                    // Height hasn't changed significantly, no resize needed
                    console.log(`📏 Skip resize - height diff: ${Math.abs(newHeight - lastResizeHeight)}px`);
                }
                
                resizeTimeout = null;
            });
        }
        
        // Set up observers for automatic height adjustment
        function setupAutoHeightObservers(contentArea) {
            if (!contentArea) return;
            
            console.log('🔧 Setting up auto-height observers');
            
            // ResizeObserver to watch for size changes
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver((entries) => {
                    console.log('📏 ResizeObserver triggered');
                    adjustWindowHeight();
                });
                resizeObserver.observe(contentArea);
                resizeObserver.observe(document.body);
            }
            
            // MutationObserver to watch for content changes
            if (typeof MutationObserver !== 'undefined') {
                const mutationObserver = new MutationObserver((mutations) => {
                    console.log('🔄 MutationObserver triggered:', mutations.length, 'mutations');
                    adjustWindowHeight();
                });
                
                mutationObserver.observe(contentArea, {
                    childList: true,
                    subtree: true,
                    characterData: true,
                    attributes: false
                });
            }
            
            // Also trigger on window resize
            window.addEventListener('resize', () => {
                console.log('📐 Window resize event');
                adjustWindowHeight();
            });
            
            // Initial height adjustment
            setTimeout(() => {
                console.log('🚀 Initial height adjustment');
                adjustWindowHeight();
            }, 100);
        }
    </script>
</body>
</html>
