<!DOCTYPE html>
<html>
<head>
    <title>MockMate AI: Response Window</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #000000;
            --secondary-bg: rgba(0, 0, 0, 0.7);
            --panel-bg: rgba(0, 0, 0, 0.7);
            --accent: #00d4ff;
            --accent-secondary: #ff6b35;
            --success: #00c896;
            --danger: #ff4757;
            --warning: #ffa502;
            --text-primary: #ffffff;
            --text-secondary: #ffffff;
            --text-muted: rgba(255, 255, 255, 0.7);
            --border: rgba(255, 255, 255, 0.15);
            --border-active: rgba(0, 212, 255, 0.4);
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.4);
            --gradient-primary: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(255, 107, 53, 0.05));
            --gradient-panel: linear-gradient(145deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
        }
        
        * { box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Inter', 'SF Pro Display', system-ui, sans-serif;
            background: transparent;
            margin: 0;
            padding: 0;
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: stretch;
            width: 1150px;
            height: auto;
            min-height: 80px;
            line-height: 1.6;
            font-size: 14px;
            overflow: visible;
            /* Remove any max-height constraints */
            max-height: none;
        }
        
        .app-container {
            width: 100%;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            position: relative;
            /* Remove any height constraints */
            max-height: none;
        }
        
        .response-window {
            width: 100%;
            min-height: 80px;
            background: rgba(0, 0, 0, 0.80);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            overflow: visible;
            position: relative;
            /* Remove any height constraints */
            max-height: none;
        }
        
        .response-window::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--gradient-primary);
            opacity: 0.3;
            pointer-events: none;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            background: var(--gradient-panel);
            position: relative;
            z-index: 2;
            gap: 12px;
            flex-shrink: 0;
        }
        
        .brand { display: flex; align-items: center; gap: 12px; }
        
        .logo {
            width: 32px; height: 32px;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; color: white;
            box-shadow: var(--shadow-sm);
        }
        
        .brand h2 {
            font-size: 18px; margin: 0; font-weight: 600; letter-spacing: -0.2px;
            background: linear-gradient(135deg, var(--accent), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .status-pill {
            background: rgba(0, 200, 150, 0.15); color: var(--success);
            padding: 6px 12px; border-radius: 20px; font-size: 12px;
            font-weight: 500; border: 1px solid rgba(0, 200, 150, 0.2);
            margin-left: 16px; animation: pulse 2s infinite;
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        .utility-btn {
            width: 28px; height: 28px; background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--border); border-radius: 6px; color: var(--text-secondary);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; font-size: 14px;
        }
        
        .utility-btn:hover { background: rgba(0, 0, 0, 0.9); color: var(--text-primary); transform: translateY(-1px); }
        .utility-btn.danger:hover { background: rgba(255, 71, 87, 0.2); color: var(--danger); border-color: var(--danger); }
        
        .content-area {
            padding: 16px; 
            margin: 0;
            background: transparent; 
            font-size: 21px;
            font-weight: bold;
            line-height: 1.3; 
            height: auto;
            overflow: visible;
            word-wrap: break-word;
            white-space: pre-wrap;
            z-index: 2;
            min-height: 40px;
            /* Allow natural expansion without scrolling */
        }
        
        .streaming-indicator {
            width: 8px; height: 8px; background: var(--accent);
            border-radius: 50%; animation: blink 1.5s infinite;
            box-shadow: 0 0 8px var(--accent);
            display: inline-block;
            margin-right: 8px;
            vertical-align: middle;
        }
        
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0.3; } }
        
        .material-icons {
            font-family: 'Material Icons'; font-weight: normal; font-style: normal;
            font-size: 20px; display: inline-block; line-height: 1; text-transform: none;
            letter-spacing: normal; word-wrap: normal; white-space: nowrap; direction: ltr;
            -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;
            -moz-osx-font-smoothing: grayscale; font-feature-settings: 'liga';
        }
        
        /* Hide Scrollbars */
        ::-webkit-scrollbar {
            width: 0px;
            height: 0px;
            background: transparent;
        }
        
        /* For Firefox */
        * {
            scrollbar-width: none;
        }
        
        /* For IE and Edge */
        body {
            -ms-overflow-style: none;
        }
        
        /* Animation for cursor in typing effect */
        .cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background-color: var(--accent);
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: middle;
        }
        
        @keyframes slideInFromBottom {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideOutToBottom {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(20px); opacity: 0; }
        }
    </style>
    <!-- Tauri API Script -->
    <script>
        // Ensure Tauri API is available in child windows
        if (!window.__TAURI__) {
            console.log('üîß Tauri API not found, attempting to load...');
            // Try to get it from parent or main context
            try {
                if (window.parent && window.parent.__TAURI__) {
                    window.__TAURI__ = window.parent.__TAURI__;
                    console.log('‚úÖ Tauri API loaded from parent window');
                } else if (window.opener && window.opener.__TAURI__) {
                    window.__TAURI__ = window.opener.__TAURI__;
                    console.log('‚úÖ Tauri API loaded from opener window');
                }
            } catch (e) {
                console.warn('‚ùå Could not access parent/opener Tauri API:', e);
            }
        } else {
            console.log('‚úÖ Tauri API already available');
        }
    </script>
</head>
<body>
    <div class="app-container">
        <div class="response-window">
            <button id="closeBtn" class="utility-btn danger" title="Close Window" style="position: absolute; top: 10px; right: 10px; z-index: 10;"><span class="material-icons">close</span></button>
            <button id="testResizeBtn" class="utility-btn" title="Test Resize" style="position: absolute; top: 10px; right: 50px; z-index: 10; background: rgba(0, 212, 255, 0.8);"><span class="material-icons">expand_more</span></button>
            <div id="contentArea" class="content-area">Waiting for AI response...</div>
        </div>
    </div>
    <script>
        let currentText = '';
        let typewriterTimeout = null;
        let streamingActive = false;
        
        // Wait for Tauri API to be available
        function waitForTauri(callback, maxAttempts = 50) {
            let attempts = 0;
            const checkTauri = () => {
                if (window.__TAURI__ && window.__TAURI__.invoke) {
                    console.log('‚úÖ Tauri API is now available');
                    callback();
                } else if (attempts < maxAttempts) {
                    attempts++;
                    console.log(`‚è≥ Waiting for Tauri API... (${attempts}/${maxAttempts})`);
                    setTimeout(checkTauri, 100);
                } else {
                    console.warn('‚ùå Tauri API not available after max attempts');
                    callback(); // Continue without Tauri
                }
            };
            checkTauri();
        }
        
        // Initialize when the window is loaded
        window.addEventListener('DOMContentLoaded', () => {
            // Get references to elements
            const closeBtn = document.getElementById('closeBtn');
            const testResizeBtn = document.getElementById('testResizeBtn');
            const contentArea = document.getElementById('contentArea');
            
            // Test resize button event listener
            testResizeBtn.addEventListener('click', async () => {
                console.log('üß™ Test resize button clicked');
                const contentArea = document.getElementById('contentArea');
                
                // Add a lot of test content to trigger resize
                const testContent = `Test content to trigger window resize!\n\nThis is line 1\nThis is line 2\nThis is line 3\nThis is line 4\nThis is line 5\nThis is line 6\nThis is line 7\nThis is line 8\nThis is line 9\nThis is line 10\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.`;
                
                contentArea.textContent = testContent;
                
                console.log('üìè Content updated, forcing resize...');
                adjustWindowHeight();
            });
            
            // Close button event listener
            closeBtn.addEventListener('click', async () => {
                console.log('Close button clicked');
                try {
                    if (window.__TAURI__ && window.__TAURI__.invoke) {
                        console.log('Attempting to close AI response window via Tauri');
                        await window.__TAURI__.invoke('close_ai_response_window');
                        console.log('Successfully closed AI response window');
                    } else {
                        console.log('Tauri not available, trying window.close()');
                        window.close();
                    }
                } catch (error) {
                    console.error('Error closing window:', error);
                    // Fallback: try window.close()
                    try {
                        window.close();
                    } catch (closeError) {
                        console.error('Error with window.close():', closeError);
                    }
                }
            });
            
            // Wait for Tauri API and then set up observers
            waitForTauri(() => {
                setupAutoHeightObservers(contentArea);
                console.log('AI Response window loaded and ready with auto-height observers');
            });
        });
        
        // Function to reset window to initial state
        function resetToInitialState() {
            console.log('üîÑ Resetting window to initial state');
            const contentArea = document.getElementById('contentArea');
            
            // Reset content
            contentArea.innerHTML = 'Waiting for AI response...';
            
            // Reset variables
            currentText = '';
            streamingActive = false;
            
            // Clear any pending timeouts
            if (typewriterTimeout) {
                clearTimeout(typewriterTimeout);
                typewriterTimeout = null;
            }
            
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
                resizeTimeout = null;
            }
            
            // Reset window size to initial state
            setTimeout(() => adjustWindowHeight(), 100);
        }
        
        // Global function to update content (called from Tauri)
        window.updateContent = function(type, data) {
            console.log('üéØ AI RESPONSE WINDOW: updateContent called with type:', type);
            console.log('üéØ AI RESPONSE WINDOW: updateContent data:', data);
            console.log('üéØ AI RESPONSE WINDOW: current streamingActive:', streamingActive);
            const contentArea = document.getElementById('contentArea');
            
            switch (type) {
                case 'stream':
                    // Main.js sends the FULL accumulated text each time, not incremental tokens
                    const fullText = data.text || '';
                    
                    // Mark that we're in a streaming session
                    if (!streamingActive) {
                        console.log('üöÄ New streaming session started - resetting to initial state');
                        resetToInitialState();
                        streamingActive = true;
                    }
                    
                    // Use the full text directly (no accumulation needed since main.js handles that)
                    currentText = fullText;
                    contentArea.innerHTML = currentText + '<span class="cursor">|</span>';
                    
                    console.log('üìù Stream update received:', {
                        fullTextLength: fullText.length,
                        textPreview: fullText.substring(0, 100) + (fullText.length > 100 ? '...' : '')
                    });
                    
                    // Adjust window height immediately for each stream update with slight delay
                    setTimeout(() => adjustWindowHeight(), 50);
                    break;
                    
                case 'complete':
                    // Clear any existing typewriter effect
                    if (typewriterTimeout) {
                        clearTimeout(typewriterTimeout);
                    }
                    
                    // Final response - use the full accumulated text
                    const finalText = data.text || currentText; // Use provided text or accumulated
                    currentText = finalText;
                    contentArea.innerHTML = currentText;
                    streamingActive = false; // Mark streaming as complete
                    
                    console.log('‚úÖ Stream completed:', {
                        finalLength: currentText.length,
                        finalText: currentText.substring(0, 100) + (currentText.length > 100 ? '...' : '')
                    });
                    
                    adjustWindowHeight();
                    break;
                    
                case 'error':
                    // Error in generating response
                    contentArea.innerHTML = `<span style="color: var(--danger);">Error: ${data.error}</span>`;
                    adjustWindowHeight();
                    break;
            }
        };
        
        // Typewriter effect function
        function startTypewriter(element) {
            let index = 0;
            element.innerHTML = '';
            
            function typeNext() {
                if (index < currentText.length) {
                    element.innerHTML = currentText.substring(0, index + 1) + '<span class="cursor">|</span>';
                    index++;
                    adjustWindowHeight();
                    typewriterTimeout = setTimeout(typeNext, 30); // 30ms per character
                } else {
                    // Remove cursor when done
                    element.innerHTML = currentText;
                    adjustWindowHeight();
                }
            }
            
            typeNext();
        }
        
        // Adjust window height based on content automatically
        let resizeTimeout = null;
        function adjustWindowHeight() {
            // Throttle resize calls to avoid excessive API calls during streaming
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            
            resizeTimeout = setTimeout(() => {
                const contentArea = document.getElementById('contentArea');
                if (contentArea && window.__TAURI__) {
                    // Use multiple animation frames for accurate measurement
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            // Get screen dimensions for dynamic max height
                            const screenHeight = window.screen.availHeight || window.screen.height || 1080;
                            const maxScreenHeight = Math.floor(screenHeight * 0.85); // Use 85% of screen height
                            
                            // Force a complete layout calculation
                            document.body.style.height = 'auto';
                            
                            // Calculate height based on content area directly
                            const contentHeight = contentArea.scrollHeight;
                            const headerHeight = 50; // Close button and padding
                            const contentPadding = 32; // Content area padding (16px * 2)
                            const windowPadding = 20; // Window padding
                            
                            const minHeight = 100;
                            const maxHeight = maxScreenHeight;
                            
                            // Calculate total window height needed based on content area
                            const totalHeight = Math.min(Math.max(contentHeight + headerHeight + contentPadding + windowPadding, minHeight), maxHeight);
                            
                            console.log('üîß Auto-adjusting window height:', {
                                documentScrollHeight: document.body.scrollHeight,
                                documentOffsetHeight: document.body.offsetHeight,
                                contentAreaScrollHeight: contentArea.scrollHeight,
                                contentAreaOffsetHeight: contentArea.offsetHeight,
                                contentHeight: contentHeight,
                                headerHeight: headerHeight,
                                contentPadding: contentPadding,
                                windowPadding: windowPadding,
                                finalHeight: totalHeight,
                                maxScreenHeight: maxScreenHeight,
                                contentText: contentArea.textContent?.substring(0, 50) + '...',
                                windowInnerHeight: window.innerHeight,
                                windowOuterHeight: window.outerHeight
                            });
                            
                            // Use Tauri to resize the window to match content
                            if (window.__TAURI__ && window.__TAURI__.invoke) {
                                window.__TAURI__.invoke('resize_ai_response_window', { height: totalHeight })
                                    .then(() => console.log(`‚úÖ Window auto-resized to ${totalHeight}px`))
                                    .catch(err => console.warn('‚ùå Resize failed:', err));
                            } else {
                                console.warn('‚ö†Ô∏è Tauri API not available for resize, using fallback');
                                // Fallback: Try to communicate with parent window or use postMessage
                                try {
                                    if (window.parent && window.parent.postMessage) {
                                        window.parent.postMessage({
                                            type: 'resize_request',
                                            height: totalHeight
                                        }, '*');
                                    }
                                } catch (e) {
                                    console.error('Fallback resize failed:', e);
                                }
                            }
                        });
                    });
                }
                resizeTimeout = null;
            }, 30); // Very responsive - 30ms throttle
        }
        
        // Set up observers for automatic height adjustment
        function setupAutoHeightObservers(contentArea) {
            if (!contentArea) return;
            
            console.log('üîß Setting up auto-height observers');
            
            // ResizeObserver to watch for size changes
            if (typeof ResizeObserver !== 'undefined') {
                const resizeObserver = new ResizeObserver((entries) => {
                    console.log('üìè ResizeObserver triggered');
                    adjustWindowHeight();
                });
                resizeObserver.observe(contentArea);
                resizeObserver.observe(document.body);
            }
            
            // MutationObserver to watch for content changes
            if (typeof MutationObserver !== 'undefined') {
                const mutationObserver = new MutationObserver((mutations) => {
                    console.log('üîÑ MutationObserver triggered:', mutations.length, 'mutations');
                    adjustWindowHeight();
                });
                
                mutationObserver.observe(contentArea, {
                    childList: true,
                    subtree: true,
                    characterData: true,
                    attributes: false
                });
            }
            
            // Also trigger on window resize
            window.addEventListener('resize', () => {
                console.log('üìê Window resize event');
                adjustWindowHeight();
            });
            
            // Initial height adjustment
            setTimeout(() => {
                console.log('üöÄ Initial height adjustment');
                adjustWindowHeight();
            }, 100);
        }
    </script>
</body>
</html>
